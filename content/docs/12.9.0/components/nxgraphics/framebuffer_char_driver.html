<!--
 Documentation/_templates/layout.html

 Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.  The
 ASF licenses this file to you under the Apache License, Version 2.0 (the
 "License"); you may not use this file except in compliance with the
 License.  You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 License for the specific language governing permissions and limitations
 under the License.
-->



<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Framebuffer Character Driver &mdash; NuttX latest documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css" />
      <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css" />
      <link rel="stylesheet" type="text/css" href="../../_static/custom.css" />

  
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
      <script src="../../_static/jquery.js"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
      <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
      <script src="../../_static/doctools.js"></script>
      <script src="../../_static/sphinx_highlight.js"></script>
      <script src="../../_static/clipboard.min.js"></script>
      <script src="../../_static/copybutton.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Sample Code" href="sample.html" />
    <link rel="prev" title="NxWM Threading" href="nxwm_threading.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
  
    <a href="../../index.html" class="icon icon-home"> NuttX
  

  
  </a>

  <!-- this version selector is quite ugly, should be probably replaced by something
       more modern -->

  <div class="version-selector">
    <select onchange="javascript:location.href = this.value;">
    
    <option value="../../../latest" selected="selected">latest</option>
    
    <option value="../../../10.0.0" >10.0.0</option>
    
    <option value="../../../10.0.1" >10.0.1</option>
    
    <option value="../../../10.1.0" >10.1.0</option>
    
    <option value="../../../10.2.0" >10.2.0</option>
    
    <option value="../../../10.3.0" >10.3.0</option>
    
    <option value="../../../11.0.0" >11.0.0</option>
    
    <option value="../../../12.0.0" >12.0.0</option>
    
    <option value="../../../12.1.0" >12.1.0</option>
    
    <option value="../../../12.2.0" >12.2.0</option>
    
    <option value="../../../12.2.1" >12.2.1</option>
    
    <option value="../../../12.3.0" >12.3.0</option>
    
    <option value="../../../12.4.0" >12.4.0</option>
    
    <option value="../../../12.5.0" >12.5.0</option>
    
    <option value="../../../12.5.1" >12.5.1</option>
    
    <option value="../../../12.6.0" >12.6.0</option>
    
    <option value="../../../12.7.0" >12.7.0</option>
    
    <option value="../../../12.8.0" >12.8.0</option>
    
    <option value="../../../12.9.0" >12.9.0</option>
    
    </select>
  </div>

  
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Table of Contents</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../index.html">Home</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../introduction/index.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../quickstart/index.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contributing/index.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../introduction/inviolables.html">The Inviolable Principles of NuttX</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../platforms/index.html">Supported Platforms</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">OS Components</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../binfmt.html">Binary Loader</a></li>
<li class="toctree-l2"><a class="reference internal" href="../drivers/index.html">Device Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nxflat.html">NXFLAT</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">NX Graphics Subsystem</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="index.html#objectives">Objectives</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#organization">Organization</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="index.html#nx-header-files">NX Header Files</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="nxgl.html">NX Graphics Library (<code class="docutils literal notranslate"><span class="pre">NXGL</span></code>)</a></li>
<li class="toctree-l4"><a class="reference internal" href="nx.html">NX</a></li>
<li class="toctree-l4"><a class="reference internal" href="nxtk.html">NX Tool Kit (<code class="docutils literal notranslate"><span class="pre">NXTK</span></code>)</a></li>
<li class="toctree-l4"><a class="reference internal" href="nxfonts.html">NX Fonts Support (<code class="docutils literal notranslate"><span class="pre">NXFONTS</span></code>)</a></li>
<li class="toctree-l4"><a class="reference internal" href="nxcursor.html">NX Cursor Support (<code class="docutils literal notranslate"><span class="pre">NXCURSOR</span></code>)</a></li>
<li class="toctree-l4"><a class="reference internal" href="nxwm_threading.html">NxWM Threading</a></li>
<li class="toctree-l4 current"><a class="current reference internal" href="#">Framebuffer Character Driver</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#nx-graphics">NX Graphics</a></li>
<li class="toctree-l5"><a class="reference internal" href="#figure-1">Figure 1</a></li>
<li class="toctree-l5"><a class="reference internal" href="#framebuffer-character-driver-details">Framebuffer Character Driver details</a></li>
<li class="toctree-l5"><a class="reference internal" href="#posix-interfaces">POSIX Interfaces</a></li>
<li class="toctree-l5"><a class="reference internal" href="#ioctl-commands">IOCTL Commands</a></li>
<li class="toctree-l5"><a class="reference internal" href="#mmap"><code class="docutils literal notranslate"><span class="pre">mmap()</span></code></a></li>
<li class="toctree-l5"><a class="reference internal" href="#framebuffer-vs-lcd-graphics-drivers">Framebuffer vs. LCD Graphics Drivers</a></li>
<li class="toctree-l5"><a class="reference internal" href="#lcd-framebuffer-front-end">LCD Framebuffer Front-End</a></li>
<li class="toctree-l5"><a class="reference internal" href="#framebuffer-graphics-library">Framebuffer Graphics Library</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="sample.html">Sample Code</a></li>
<li class="toctree-l4"><a class="reference internal" href="appendix.html">Appendix</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../paging.html">On-Demand Paging</a></li>
<li class="toctree-l2"><a class="reference internal" href="../audio/index.html">Audio Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../filesystem/index.html">NuttX File System</a></li>
<li class="toctree-l2"><a class="reference internal" href="../libs/index.html">NuttX libraries</a></li>
<li class="toctree-l2"><a class="reference internal" href="../net/index.html">Network Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mm/index.html">Memory Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="../syscall.html">Syscall Layer</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tools/index.html"><code class="docutils literal notranslate"><span class="pre">/tools</span></code> Host Tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="../arch/index.html">Architecture-Specific Code</a></li>
<li class="toctree-l2"><a class="reference internal" href="../boards.html">Boards Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cmake.html">CMake Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../openamp.html">OpenAMP Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../video.html">Video Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../crypto.html">Crypto API Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../wireless.html">Wireless Subsystem</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../applications/index.html">Applications</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../implementation/index.html">Implementation Details</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../reference/index.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../faq/index.html">FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../guides/index.html">Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../glossary.html">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../logos/index.html">NuttX Logos</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">NuttX</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">OS Components</a></li>
          <li class="breadcrumb-item"><a href="index.html">NX Graphics Subsystem</a></li>
      <li class="breadcrumb-item active">Framebuffer Character Driver</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/components/nxgraphics/framebuffer_char_driver.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="framebuffer-character-driver">
<h1>Framebuffer Character Driver<a class="headerlink" href="#framebuffer-character-driver" title="Permalink to this heading"></a></h1>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Migrated from:
<a class="reference external" href="https://cwiki.apache.org/confluence/display/NUTTX/Framebuffer+Character+Driver">https://cwiki.apache.org/confluence/display/NUTTX/Framebuffer+Character+Driver</a></p>
</div>
<section id="nx-graphics">
<h2>NX Graphics<a class="headerlink" href="#nx-graphics" title="Permalink to this heading"></a></h2>
<p>NuttX has supported higher level graphics for some time with
the OS’s <a class="reference internal" href="index.html"><span class="doc">NX Graphics Subsystem</span></a> and application
oriented <a class="reference internal" href="../../applications/graphics/nxwidgets/index.html"><span class="doc">NxWidgets</span></a> and the tiny
window manager <a class="reference internal" href="../../applications/graphics/nxwm/index.html"><span class="doc">NxWM</span></a>.
These are higher level in the sense that the primary
graphical function is to support windowing and control
of tools and toolbars within windows. These graphics
tools often do not meet the needs
of developers with very low end graphics and minimal display
requirements.</p>
</section>
<section id="figure-1">
<h2>Figure 1<a class="headerlink" href="#figure-1" title="Permalink to this heading"></a></h2>
<p>The framebuffer character driver, along with the option LCD
framebuffer interface, is an optional lighter-weight graphics interface.</p>
<img alt="../../_images/GraphicsInterfaces.png" src="../../_images/GraphicsInterfaces.png" />
</section>
<section id="framebuffer-character-driver-details">
<h2>Framebuffer Character Driver details<a class="headerlink" href="#framebuffer-character-driver-details" title="Permalink to this heading"></a></h2>
<p>A <cite>framebuffer character driver</cite> has been recently been added
to bypass the complexity of <cite>NX</cite> and to provide a direct
application interface to the framebuffer graphic device.
The framebuffer buffer character devices, as with all
character devices, provides the interface to the graphics
device via stand POSIX VFS commands (<code class="docutils literal notranslate"><span class="pre">open()</span></code>, <code class="docutils literal notranslate"><span class="pre">close()</span></code>,
<code class="docutils literal notranslate"><span class="pre">read()</span></code>, <code class="docutils literal notranslate"><span class="pre">write()</span></code>, <code class="docutils literal notranslate"><span class="pre">seek()</span></code>, …), through IOCTL commands,
and for this driver via the <code class="docutils literal notranslate"><span class="pre">mmap()</span></code> function. These
interfaces are described below,</p>
<p>The framebuffer character driver is located in the NuttX
source tree at <code class="docutils literal notranslate"><span class="pre">drivers/video/fb.c</span></code>. It is enabled in the
build with <code class="docutils literal notranslate"><span class="pre">CONFIG_VIDEO_FB=y</span></code>. In order to register the
framebuffer driver, you will need to include logic in the
your board-specific start-up function that calls
<code class="docutils literal notranslate"><span class="pre">fb_register()</span></code> That code sequence might look something
like:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;nuttx/video/fb.h&gt;</span>

<span class="cp">#ifdef CONFIG_VIDEO_FB</span>
<span class="cm">/* Initialize and register the simulated framebuffer driver */</span>

<span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fb_register</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ret</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="n">syslog</span><span class="p">(</span><span class="n">LOG_ERR</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;ERROR: fb_register() failed: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">ret</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="cp">#endif</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">fb_register()</span></code> function takes two parameters:</p>
<ul class="simple">
<li><p><cite>display</cite>. The display number for the case of boards
supporting multiple displays or for hardware that supports
multiple layers (each layer is consider a display). Typically zero.</p></li>
<li><p><cite>plane</cite>. Identifies the color plane on hardware that supports
separate framebuffer “planes” for each color component.
Should be zero because no planar hardware is currently
supported by NuttX.</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">fb_register()</span></code> will register the framebuffer character device
at <code class="docutils literal notranslate"><span class="pre">/dev/fb</span></code> <cite>N</cite> where <cite>N</cite> is the display number if the devices
supports only a single plane. If the hardware supports
multiple color planes, then the device will be registered
at <code class="docutils literal notranslate"><span class="pre">/dev/fb</span></code> <cite>N-M</cite> where <cite>N</cite> is the again display number but <cite>M</cite>
is the display plane.</p>
<p>There is a simple example at <code class="docutils literal notranslate"><span class="pre">apps/examples/fb</span></code> that provides
an illustration of most of the following interfacing methods.</p>
</section>
<section id="posix-interfaces">
<h2>POSIX Interfaces<a class="headerlink" href="#posix-interfaces" title="Permalink to this heading"></a></h2>
<p>The interaction with the framebuffer character driver via POSIX
VFS interface calls is the same as for other character drivers.
The only aspect that might require some additional discussion
is the use of <code class="docutils literal notranslate"><span class="pre">read()</span></code>, <code class="docutils literal notranslate"><span class="pre">write()</span></code>, and <code class="docutils literal notranslate"><span class="pre">seek()</span></code>.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">read()</span></code> returns data from the framebuffer memory and
updates the file position based on the number of bytes read.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">write()</span></code> puts data into the framebuffer memory and
also updates the file position.</p></li>
</ul>
<p>That file position is initially set to the position
zero meaning the beginning of the framebuffer. It is
advanced each time you <code class="docutils literal notranslate"><span class="pre">read()</span></code> from or <code class="docutils literal notranslate"><span class="pre">write()</span></code> to the
framebuffer. Is also updated by <code class="docutils literal notranslate"><span class="pre">seek()</span></code>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">seek()</span></code> sets the file position to any desired
location within the framebuffer.</p></li>
</ul>
<p>The file position is in units of <cite>bytes</cite>. This can be
confusing because other positional data may be in units
<cite>pixels</cite>. Pixels have different <cite>depth</cite> in different displays,
that is, different graphic hardware may support pixels with
differing bits-per-pixel. The pixel depth can be obtained
using one of the IOCTL commands listed below. Since the file
position is in bytes, the bits-per-pixel must be taken account
when using <code class="docutils literal notranslate"><span class="pre">read()</span></code>, <code class="docutils literal notranslate"><span class="pre">write()</span></code>, and <code class="docutils literal notranslate"><span class="pre">seek()</span></code>. The usual conversion
from pixels to bytes is:</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">start_byte</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">start_pixel</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">bits_per_pixel</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span>
<span class="n">end_byte</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">end_pixel</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">bits_per_pixel</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">7</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span>
</pre></div>
</div>
<p>While the framebuffer may be accessed with these POSIX interfaces,
a more typical way of interacting with the framebuffer from an
application would involve use of <code class="docutils literal notranslate"><span class="pre">mmap()</span></code> as described below.</p>
</section>
<section id="ioctl-commands">
<h2>IOCTL Commands<a class="headerlink" href="#ioctl-commands" title="Permalink to this heading"></a></h2>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">FBIOGET_VIDEOINFO</span></code>. Get color plane info. Its argument is
pointer a writable instance of <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fb_videoinfo_s</span></code>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">fb_videoinfo_s</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w">    </span><span class="n">fmt</span><span class="p">;</span><span class="w">         </span><span class="cm">/* see FB_FMT_*  */</span>
<span class="w">    </span><span class="n">fb_coord_t</span><span class="w"> </span><span class="n">xres</span><span class="p">;</span><span class="w">        </span><span class="cm">/* Horizontal resolution in pixel columns */</span>
<span class="w">    </span><span class="n">fb_coord_t</span><span class="w"> </span><span class="n">yres</span><span class="p">;</span><span class="w">        </span><span class="cm">/* Vertical resolution in pixel rows */</span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w">    </span><span class="n">nplanes</span><span class="p">;</span><span class="w">     </span><span class="cm">/* Number of color planes supported */</span>
<span class="p">};</span>
</pre></div>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">FBIOGET_PLANEINFO</span></code>. Get video plane info. It received
a pointer to a writable instance of <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fb_planeinfo_s</span></code> as its argument:</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">fb_planeinfo_s</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">FAR</span><span class="w"> </span><span class="kt">void</span><span class="w">  </span><span class="o">*</span><span class="n">fbmem</span><span class="p">;</span><span class="w">       </span><span class="cm">/* Start of frame buffer memory */</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w">   </span><span class="n">fblen</span><span class="p">;</span><span class="w">       </span><span class="cm">/* Length of frame buffer memory in bytes */</span>
<span class="w">    </span><span class="n">fb_coord_t</span><span class="w"> </span><span class="n">stride</span><span class="p">;</span><span class="w">      </span><span class="cm">/* Length of a line in bytes */</span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w">    </span><span class="n">display</span><span class="p">;</span><span class="w">     </span><span class="cm">/* Display number */</span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w">    </span><span class="n">bpp</span><span class="p">;</span><span class="w">         </span><span class="cm">/* Bits per pixel */</span>
<span class="p">};</span>
</pre></div>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">FBIOGET_CMAP</span></code> and <code class="docutils literal notranslate"><span class="pre">FBIOPUT_CMAP</span></code>. Get/Put RGB color mapping.
These commands are available only if the hardware and
framebuffer driver support color mapping (<code class="docutils literal notranslate"><span class="pre">CONFIG_FB_CMAP=y</span></code>).
They each take a pointer to an instance of <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fb_cmap_s</span></code>
as an argument (writeable for <code class="docutils literal notranslate"><span class="pre">FBIOGET_CMAP</span></code> and read-only
for <code class="docutils literal notranslate"><span class="pre">FBIOPUT_CMAP</span></code>).</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#ifdef CONFIG_FB_CMAP</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">fb_cmap_s</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">uint16_t</span><span class="w">  </span><span class="n">first</span><span class="p">;</span><span class="w">        </span><span class="cm">/* Offset offset first color entry in tables */</span>
<span class="w">    </span><span class="kt">uint16_t</span><span class="w">  </span><span class="n">len</span><span class="p">;</span><span class="w">          </span><span class="cm">/* Number of color entries  in tables */</span>

<span class="w">    </span><span class="cm">/* Tables of  color component.  Any may be NULL if not used */</span>

<span class="w">    </span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="n">red</span><span class="p">;</span><span class="w">           </span><span class="cm">/* Table of 8-bit red values */</span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="n">green</span><span class="p">;</span><span class="w">         </span><span class="cm">/* Table of 8-bit green values */</span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="n">blue</span><span class="p">;</span><span class="w">          </span><span class="cm">/* Table of 8-bit blue values */</span>
<span class="cp">#ifdef CONFIG_FB_TRANSPARENCY</span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="n">transp</span><span class="p">;</span><span class="w">        </span><span class="cm">/* Table of 8-bit transparency */</span>
<span class="cp">#endif</span>
<span class="p">};</span>
<span class="cp">#endif</span>
</pre></div>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">FBIOGET_CURSOR</span></code>. Get cursor attributes. This command is
available only if the hardware and framebuffer driver
support cursors (<code class="docutils literal notranslate"><span class="pre">CONFIG_FB_HWCURSOR=y</span></code>). It take a pointer
to a writable instance of <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fb_cursorattrib_s</span></code>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#ifdef CONFIG_FB_HWCURSOR</span>
<span class="cp">#ifdef CONFIG_FB_HWCURSORIMAGE</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">fb_cursorimage_s</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">fb_coord_t</span><span class="w">     </span><span class="n">width</span><span class="p">;</span><span class="w">    </span><span class="cm">/* Width of the cursor image in pixels */</span>
<span class="w">    </span><span class="n">fb_coord_t</span><span class="w">     </span><span class="n">height</span><span class="w">    </span><span class="cm">/* Height of the cursor image in pixels */</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="n">image</span><span class="p">;</span><span class="w">    </span><span class="cm">/* Pointer to image data */</span>
<span class="p">};</span>
<span class="cp">#endif</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">fb_cursorpos_s</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">fb_coord_t</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w">            </span><span class="cm">/* X position in pixels */</span>
<span class="w">    </span><span class="n">fb_coord_t</span><span class="w"> </span><span class="n">y</span><span class="p">;</span><span class="w">            </span><span class="cm">/* Y position in rows */</span>
<span class="p">};</span>

<span class="cp">#ifdef CONFIG_FB_HWCURSORSIZE</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">fb_cursorsize_s</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">fb_coord_t</span><span class="w"> </span><span class="n">h</span><span class="p">;</span><span class="w">             </span><span class="cm">/* Height in rows */</span>
<span class="w">    </span><span class="n">fb_coord_t</span><span class="w"> </span><span class="n">w</span><span class="p">;</span><span class="w">             </span><span class="cm">/* Width in pixels */</span>
<span class="p">};</span>
<span class="cp">#endif</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">fb_cursorattrib_s</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_FB_HWCURSORIMAGE</span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">fmt</span><span class="p">;</span><span class="w">                   </span><span class="cm">/* Video format of cursor */</span>
<span class="cp">#endif</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">fb_cursorpos_s</span><span class="w">  </span><span class="n">pos</span><span class="p">;</span><span class="w">    </span><span class="cm">/* Current cursor position */</span>
<span class="cp">#ifdef CONFIG_FB_HWCURSORSIZE</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">fb_cursorsize_s</span><span class="w"> </span><span class="n">mxsize</span><span class="p">;</span><span class="w"> </span><span class="cm">/* Maximum cursor size */</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">fb_cursorsize_s</span><span class="w"> </span><span class="n">size</span><span class="p">;</span><span class="w">   </span><span class="cm">/* Current size */</span>
<span class="cp">#endif</span>
<span class="p">};</span>
<span class="cp">#endif</span>
</pre></div>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">FBIOPUT_CURSOR</span></code>. Set cursor attributes. This command is
available only if the hardware and framebuffer driver
support cursors (<code class="docutils literal notranslate"><span class="pre">CONFIG_FB_HWCURSOR=y</span></code>). It take a
pointer to a writable instance of <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fb_setcursor_s</span></code>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#ifdef CONFIG_FB_HWCURSOR</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">fb_setcursor_s</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">flags</span><span class="p">;</span><span class="w">                </span><span class="cm">/* See FB_CUR_* definitions */</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">fb_cursorpos_s</span><span class="w"> </span><span class="n">pos</span><span class="p">;</span><span class="w">    </span><span class="cm">/* Cursor position */</span>
<span class="cp">#ifdef CONFIG_FB_HWCURSORSIZE</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">fb_cursorsize_s</span><span class="w">  </span><span class="n">size</span><span class="p">;</span><span class="w"> </span><span class="cm">/* Cursor size */</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_FB_HWCURSORIMAGE</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">fb_cursorimage_s</span><span class="w"> </span><span class="n">img</span><span class="p">;</span><span class="w">  </span><span class="cm">/* Cursor image */</span>
<span class="cp">#endif</span>
<span class="p">};</span>
<span class="cp">#endif</span>
</pre></div>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">FBIO_UPDATE</span></code>. This IOCTL command updates a rectangular region
in the framebuffer. Some hardware requires that there be
such a notification when a change is made to the
framebuffer (see, for example, the discussion of LCD drivers
below). This IOTCL command is if <code class="docutils literal notranslate"><span class="pre">CONFIG_NX_UPDATE=y</span></code> is
defined. It takes a pointer to a read-only instance of
<code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nxgl_rect_s</span></code> that describes the region to be updated:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">nxgl_rect_s</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">nxgl_point_s</span><span class="w"> </span><span class="n">pt1</span><span class="p">;</span><span class="w"> </span><span class="cm">/* Upper, left-hand corner */</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">nxgl_point_s</span><span class="w"> </span><span class="n">pt2</span><span class="p">;</span><span class="w"> </span><span class="cm">/* Lower, right-hand corner */</span>
<span class="p">};</span>
</pre></div>
</div>
</li>
</ul>
</section>
<section id="mmap">
<h2><code class="docutils literal notranslate"><span class="pre">mmap()</span></code><a class="headerlink" href="#mmap" title="Permalink to this heading"></a></h2>
<p>Above we talked about using <code class="docutils literal notranslate"><span class="pre">read()</span></code>, <code class="docutils literal notranslate"><span class="pre">write()</span></code>, and <code class="docutils literal notranslate"><span class="pre">seek()</span></code> to
access the framebuffer. The simplest way to access the
framebuffer, however, is by using the <code class="docutils literal notranslate"><span class="pre">mmap()</span></code> to map
the framebuffer memory into the application memory
space. The following <code class="docutils literal notranslate"><span class="pre">mmap()</span></code> command, for example, can
be used to obtain a pointer to a read-able, write-able
copy of the framebuffer:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">FAR</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">fbmem</span><span class="p">;</span>

<span class="n">fbmem</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mmap</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="n">fblen</span><span class="p">,</span><span class="w"> </span><span class="n">PROT_READ</span><span class="o">|</span><span class="n">PROT_WRITE</span><span class="p">,</span><span class="w"> </span><span class="n">MAP_SHARED</span><span class="o">|</span><span class="n">MAP_FILE</span><span class="p">,</span><span class="w"> </span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">state</span><span class="p">.</span><span class="n">fbmem</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">MAP_FAILED</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="cm">/* Handle failure */</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">}</span>

<span class="n">printf</span><span class="p">(</span><span class="s">&quot;Mapped FB: %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">fbmem</span><span class="p">);</span>
</pre></div>
</div>
<p>Where fd is the file descriptor of the opened framebuffer
character driver and <code class="docutils literal notranslate"><span class="pre">fblen</span></code> was obtained via an IOCTL
command as described above. NOTE that the framebuffer
buffer pointer is also available within the values
returned by the IOCTL commands. The address is a
kernel memory address and may not be valid in all
build configurations. Hence, <code class="docutils literal notranslate"><span class="pre">mmap()</span></code> is the preferred,
portable way to get the framebuffer address.</p>
</section>
<section id="framebuffer-vs-lcd-graphics-drivers">
<h2>Framebuffer vs. LCD Graphics Drivers<a class="headerlink" href="#framebuffer-vs-lcd-graphics-drivers" title="Permalink to this heading"></a></h2>
<p>Framebuffer graphics drivers are very common in high-end CPUs
but most low-end, embedded hardware will not support a
framebuffer.</p>
<p>A framebuffer graphics driver supports a region of memory
that is shared both by the software and by the graphics
hardware. Any modification to the framebuffer memory
results in a corresponding modification on the display
with no intervening software interaction. Some video
memory is dual ported to support concurrent video processor
and application processor accesses; or perhaps the LCD
peripheral just constantly DMAs the framebuffer memory
to the graphics hardware.</p>
<p>Most low-end embedded MCUs have a much simpler hardware
interface: The interface to the LCD may be through a simple
parallel interface or, more commonly, through a slower serial
interface such as SPI. In order to support such low-end
hardware with the framebuffer character driver, a special
software layer called the <cite>Framebuffer LCD Front End</cite> has
been developed. This is the topic of the next paragraph.</p>
</section>
<section id="lcd-framebuffer-front-end">
<h2>LCD Framebuffer Front-End<a class="headerlink" href="#lcd-framebuffer-front-end" title="Permalink to this heading"></a></h2>
<p>The <cite>LCD Framebuffer Front-End</cite> provides a standard NuttX
framebuffer interface, but works on top of a standard
parallel or serial LCD driver. It provides the framebuffer,
the framebuffer interface, and the hooks to adapt the LCD
driver. The LCD framebuffer front-end can be found in the
NuttX source tree at <code class="docutils literal notranslate"><span class="pre">drivers/lcd/lcd_framebuffer.c</span></code>.</p>
<p>In order to provide updates to the LCD hardware after
updates to the framebuffer, the LCD framebuffer front-end
must be notified when significant changes to the framebuffer
have been made. This notification is supported when
<code class="docutils literal notranslate"><span class="pre">CONFIG_NX_UPDATE=y</span></code> is defined in the configuration. In
this case, the LCD framebuffer front-end will support
the special. OS-internal interface function <code class="docutils literal notranslate"><span class="pre">nx_notify_rectangle()</span></code>
which defines the rectangular region in the framebuffer that
has been changed. In response to a call to <code class="docutils literal notranslate"><span class="pre">nx_notify_rectangle()</span></code>
will use the lower-level LCD interface to update only that
rectangular region on the display.</p>
<p>This kind of update for standard LCD drivers is very efficient:
It is usually more efficient to update a region on the
display than it is for form a complex image with text and
line drawing; the updated region seems to update very
quickly because of that. In fact, many of the low-end
LCD drivers already include an internal framebuffer to
support this style of LCD update.</p>
<p>When used with LCD character driver, the <code class="docutils literal notranslate"><span class="pre">nx_notify_rectangle()</span></code>
function will be called by the character river in response
to the <code class="docutils literal notranslate"><span class="pre">FBIO_UPDATE</span> <span class="pre">IOCTL</span></code> command.</p>
<p>Another advantage of the framebuffer, both the LCD internal
framebuffer and the framebuffer character driver, is
that super-efficient reading of the LCD display memory:
The LCD display memory is not read at all! The read is
from the copy in the framebuffer.</p>
<p>Of course, using both an LCD internal framebuffer with the
framebuffer character drivers is wasteful; one framebuffer
is enough!</p>
<p>As a caution, it is important to remember that a framebuffer
can be quite large. For example, a 480x320 display with
16-bit RGB pixels would require an allocated framebuffer
of size 300 KiB. This is inappropriate with most small
MCUs (unless they support external memory). For tiny displays,
such as 128x64 1-bit monochromatic displays, the framebuffer
memory usage is not bad: 1 KiB in that example.</p>
</section>
<section id="framebuffer-graphics-library">
<h2>Framebuffer Graphics Library<a class="headerlink" href="#framebuffer-graphics-library" title="Permalink to this heading"></a></h2>
<p>Now the missing part is some kind of application-space
framebuffer graphics library. The NuttX framebuffer
driver is superficially similar to the Linux framebuffer
driver so there is a lot of support for Linux
framebuffer graphics support that should be easily ported to
NuttX – Perhaps DirectFB would be an GPL option? SDL with its
MIT license might be a more compatible source for such a port.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="nxwm_threading.html" class="btn btn-neutral float-left" title="NxWM Threading" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="sample.html" class="btn btn-neutral float-right" title="Sample Code" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, The Apache Software Foundation.</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>