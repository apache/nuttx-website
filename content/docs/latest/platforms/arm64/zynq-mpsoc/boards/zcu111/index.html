<!--
 Documentation/_templates/layout.html

 Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.  The
 ASF licenses this file to you under the Apache License, Version 2.0 (the
 "License"); you may not use this file except in compliance with the
 License.  You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 License for the specific language governing permissions and limitations
 under the License.
-->

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Zynq UltraScale+ RFSoC ZCU111 &mdash; NuttX latest documentation</title>
      <link rel="stylesheet" href="../../../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../../../_static/copybutton.css" type="text/css" />
      <link rel="stylesheet" href="../../../../../_static/tabs.css" type="text/css" />
      <link rel="stylesheet" href="../../../../../_static/custom.css" type="text/css" />
    <link rel="shortcut icon" href="../../../../../_static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="../../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../../../_static/jquery.js"></script>
        <script src="../../../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script data-url_root="../../../../../" id="documentation_options" src="../../../../../_static/documentation_options.js"></script>
        <script src="../../../../../_static/doctools.js"></script>
        <script src="../../../../../_static/sphinx_highlight.js"></script>
        <script src="../../../../../_static/clipboard.min.js"></script>
        <script src="../../../../../_static/copybutton.js"></script>
    <script src="../../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../search.html" />
    <link rel="next" title="Microchip AVR" href="../../../../avr/index.html" />
    <link rel="prev" title="Zynq UltraScale+ MPSoC" href="../../index.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
  
    <a href="../../../../../index.html" class="icon icon-home"> NuttX
  

  
  </a>

  <!-- this version selector is quite ugly, should be probably replaced by something
       more modern -->

  <div class="version-selector">
    <select onchange="javascript:location.href = this.value;">
    
    <option value="../../../../../../latest" selected="selected">latest</option>
    
    <option value="../../../../../../10.0.0" >10.0.0</option>
    
    <option value="../../../../../../10.0.1" >10.0.1</option>
    
    <option value="../../../../../../10.1.0" >10.1.0</option>
    
    <option value="../../../../../../10.2.0" >10.2.0</option>
    
    <option value="../../../../../../10.3.0" >10.3.0</option>
    
    <option value="../../../../../../11.0.0" >11.0.0</option>
    
    <option value="../../../../../../12.0.0" >12.0.0</option>
    
    <option value="../../../../../../12.1.0" >12.1.0</option>
    
    <option value="../../../../../../12.2.0" >12.2.0</option>
    
    <option value="../../../../../../12.2.1" >12.2.1</option>
    
    <option value="../../../../../../12.3.0" >12.3.0</option>
    
    <option value="../../../../../../12.4.0" >12.4.0</option>
    
    <option value="../../../../../../12.5.0" >12.5.0</option>
    
    <option value="../../../../../../12.5.1" >12.5.1</option>
    
    </select>
  </div>

  
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Table of Contents</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../../../../index.html">Home</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../introduction/index.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../quickstart/index.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../contributing/index.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../introduction/inviolables.html">The Inviolable Principles of NuttX</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../../../index.html">Supported Platforms</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../../../../arm/index.html">ARM</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../../../index.html">ARM64</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../../../a64/index.html">Allwinner A64</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../fvp-v8r/index.html">fvp-v8r</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../imx8/index.html">NXP i.MX8</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../imx9/index.html">NXP i.MX9</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../qemu/index.html">qemu</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../rk3399/index.html">Rockchip rk3399</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="../../index.html">Zynq UltraScale+ MPSoC</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="../../index.html#peripheral-support">Peripheral Support</a></li>
<li class="toctree-l4 current"><a class="reference internal" href="../../index.html#supported-boards">Supported Boards</a><ul class="current">
<li class="toctree-l5 current"><a class="current reference internal" href="#">Zynq UltraScale+ RFSoC ZCU111</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../../avr/index.html">Microchip AVR</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../ceva/index.html">CEVA</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../hc/index.html">HC</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../mips/index.html">MIPS</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../misco/index.html">Misoc</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../or1k/index.html">OpenRISC</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../renesas/index.html">Renesas</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../risc-v/index.html">RISC-V</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../sim/index.html">Simulators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../sparc/index.html">SPARC</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../tricore/index.html">TriCore</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../x86/index.html">Intel 80x86</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../x86_64/index.html">Intel 80x86_64</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../xtensa/index.html">Xtensa</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../z16/index.html">Z16</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../z80/index.html">Z80</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../components/index.html">OS Components</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../applications/index.html">Applications</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../implementation/index.html">Implementation Details</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../reference/index.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../faq/index.html">FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../guides/index.html">Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../glossary.html">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../logos/index.html">NuttX Logos</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../index.html">NuttX</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../../../index.html">Supported Platforms</a></li>
          <li class="breadcrumb-item"><a href="../../../index.html">ARM64</a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Zynq UltraScale+ MPSoC</a></li>
      <li class="breadcrumb-item active">Zynq UltraScale+ RFSoC ZCU111</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../../../_sources/platforms/arm64/zynq-mpsoc/boards/zcu111/index.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="zynq-ultrascale-rfsoc-zcu111">
<h1>Zynq UltraScale+ RFSoC ZCU111<a class="headerlink" href="#zynq-ultrascale-rfsoc-zcu111" title="Permalink to this heading"></a></h1>
<p>The <a class="reference external" href="https://www.xilinx.com/products/boards-and-kits/zcu111.html">ZCU111</a> is a
development board based on the Zynq UltraScale+ RFSoC(XCZU28DR) from XilinX(AMD).</p>
<section id="features">
<h2>Features<a class="headerlink" href="#features" title="Permalink to this heading"></a></h2>
<ul class="simple">
<li><dl class="simple">
<dt><strong>RF Data Converter</strong></dt><dd><ul>
<li><p><strong>12-bit ADC:</strong> 8, Max Rate 4.096G</p></li>
<li><p><strong>14-bit DAC:</strong> 8, Max Rate 6.554G</p></li>
<li><p><strong>SD-FEC:</strong> SD-FEC</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>Memory</strong></dt><dd><ul>
<li><p><strong>PS DDR4:</strong> 4GB 64-bit SODIMM</p></li>
<li><p><strong>SD-Card:</strong> Yes</p></li>
<li><p><strong>M.2 SATA Connector:</strong> Yes</p></li>
<li><p><strong>QSPI:</strong> 2</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>Communications &amp; Networking</strong></dt><dd><ul>
<li><p><strong>USB UART/JTAG:</strong> 1</p></li>
<li><p><strong>RJ45:</strong> 1</p></li>
<li><p><strong>SFP+:</strong> 4</p></li>
<li><p><strong>USB 3.0:</strong> 1</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>Expansion Connectors</strong></dt><dd><ul>
<li><p><strong>FMC-HPC Connector:</strong> 2</p></li>
<li><p><strong>PMOD:</strong> 2</p></li>
<li><p><strong>RFMC 1.0:</strong> 2</p></li>
<li><p><strong>QSPI:</strong> 2</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>Control &amp; I/O</strong></dt><dd><ul>
<li><p><strong>I2C:</strong> Yes</p></li>
<li><p><strong>PMBUS:</strong> Yes</p></li>
<li><p><strong>JTAG PC4 Header:</strong> Yes</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>Boot Options</strong></dt><dd><ul>
<li><p><strong>ISD Boot:</strong> Yes</p></li>
<li><p><strong>QSPI Boot:</strong> Yes</p></li>
<li><p><strong>JTAG Boot:</strong> Yes</p></li>
</ul>
</dd>
</dl>
</li>
<li><p><strong>DDR4 SODIMM:</strong> 4GB 64-bit, 2400MT/s, attached to Processor Subsystem (PS)</p></li>
</ul>
</section>
<section id="serial-console">
<h2>Serial Console<a class="headerlink" href="#serial-console" title="Permalink to this heading"></a></h2>
<p>Serial console for the PS:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Pin</p></th>
<th class="head"><p>Signal</p></th>
<th class="head"><p>Notes</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>MIO18</p></td>
<td><p>UART0 TX</p></td>
<td><p>USB UART COM0</p></td>
</tr>
<tr class="row-odd"><td><p>MIO19</p></td>
<td><p>UART0 RX</p></td>
<td><p>USB UART COM0</p></td>
</tr>
</tbody>
</table>
<p>PS-side UART interface and is connected to the FTDI U34 FT4232HL USB-to-Quad-UART
bridge port B Connect ZCU111 to our computer with the USB Cable. On our computer
start a Serial Terminal and connect to the USB Serial Port at <strong>115200 bps</strong>.
NuttX will appear in the Serial Console when it boots on zcu111.</p>
</section>
<section id="leds-and-buttons">
<h2>LEDs and Buttons<a class="headerlink" href="#leds-and-buttons" title="Permalink to this heading"></a></h2>
<p>The PS-side pushbutton SW19 is connected to MIO22 (pin U1.Y28). The PS-side LED DS50,
which is physically placed adjacent to the pushbutton, is connected to MIO23(pin U1.U29).</p>
</section>
<section id="configurations">
<h2>Configurations<a class="headerlink" href="#configurations" title="Permalink to this heading"></a></h2>
<p>Each configuration is maintained in a sub-directory and can be selected as follow:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>tools/configure.sh zcu111:&lt;subdir&gt;
</pre></div>
</div>
<p>Where &lt;subdir&gt; is one of the following:</p>
<section id="jtag">
<h3>jtag<a class="headerlink" href="#jtag" title="Permalink to this heading"></a></h3>
<p>Basic NuttShell configuration for JTAG boot mode (nsh console enabled in UART0,
UART and JTAG exposed via FT4232HL USB-to-Quad-UART bridge port and USB cable).</p>
</section>
<section id="nsh">
<h3>nsh<a class="headerlink" href="#nsh" title="Permalink to this heading"></a></h3>
<p>Basic NuttShell configuration for Flash boot mode. We need create boot image with
zynqmp_fsbl.elf, zynqmp_pmufw.elf, bl31.elf and nuttx.elf in Vivado SDK or XSCT
shell. Also we need copy BOOT.BIN into SD Card(in SD card boot mode) or Flash it
into the QSPI FLASH(in QSPI boot mode).</p>
</section>
</section>
<section id="arm64-toolchain">
<h2>ARM64 Toolchain<a class="headerlink" href="#arm64-toolchain" title="Permalink to this heading"></a></h2>
<p>There are two ways to install the toolchain for Zynq MPSoC:
The first way is download the ARM64 Toolchain <code class="docutils literal notranslate"><span class="pre">aarch64-none-elf</span></code> from
<a class="reference external" href="https://developer.arm.com/downloads/-/arm-gnu-toolchain-downloads">Arm GNU Toolchain Downloads</a>.
Add the downloaded toolchain <code class="docutils literal notranslate"><span class="pre">gcc-arm-...-aarch64-none-elf/bin</span></code>
to the <code class="docutils literal notranslate"><span class="pre">PATH</span></code> Environment Variable such as:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span><span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;export PATH=/home/username/tools/gcc-arm-11.2-2022.02-x86_64-aarch64-none-elf/bin:</span><span class="nv">$PATH</span><span class="s2">&quot;</span><span class="w"> </span>&gt;&gt;<span class="w"> </span>~/.profile
</pre></div>
</div>
<p>You can edit your .profile files if you don’t use bash.</p>
<p>The second way is install Vivado SDK or Vitis development environment which included a complete
<code class="docutils literal notranslate"><span class="pre">aarch64-none-elf</span></code> toolchain and we also add it to the <code class="docutils literal notranslate"><span class="pre">PATH</span></code> Environment Variable such as:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span><span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;export PATH=/home/username/tools/Xilinx/SDK/2018.3/gnu/aarch64/lin/aarch64-none/bin:</span><span class="nv">$PATH</span><span class="s2">&quot;</span><span class="w"> </span>&gt;&gt;<span class="w"> </span>~/.profile
</pre></div>
</div>
<p>You can edit your .profile files if you don’t use bash.</p>
<p>Note: nuttx.elf build by toolchain install in first way can’t be debuged by Vivado SDK which use
toolchain of second way for gdb version incompatibility.</p>
<p>Check the ARM64 Toolchain:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>aarch64-none-elf-gcc<span class="w"> </span>-v
</pre></div>
</div>
</section>
<section id="building">
<h2>Building<a class="headerlink" href="#building" title="Permalink to this heading"></a></h2>
<p>There are two types of NuttX image for Zynq MPSoC: debug by JTAG and boot from FLASH.</p>
<section id="debug-by-jtag">
<h3>debug by jtag<a class="headerlink" href="#debug-by-jtag" title="Permalink to this heading"></a></h3>
<p>We just configure the NuttX project and build the project:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span><span class="nb">cd</span><span class="w"> </span>nuttx
<span class="gp">$ </span>tools/configure.sh<span class="w"> </span>zcu111:jtag
<span class="gp">$ </span>make
</pre></div>
</div>
<p>Set the Project to nuttx and Application to nuttx.elf for psu_cortexa53_0 in Vivado SDK Debug Configuration.
Just click Debug button then we can debug NuttX.</p>
</section>
<section id="boot-from-flash">
<h3>boot from flash<a class="headerlink" href="#boot-from-flash" title="Permalink to this heading"></a></h3>
<p>To boot from FLASH, we have to create BOOT.BIN image and flash it into QSPI FLASH or SD card. To create BOOT.BIN
in addition to building nuttx.elf, we also need to build zynqmp_fsbl.elf, zynqmp_pmufw.elf and bl31.elf
To build nuttx.elf we just configure the NuttX project and build the project:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span><span class="nb">cd</span><span class="w"> </span>nuttx
<span class="gp">$ </span>tools/configure.sh<span class="w"> </span>zcu111:nsh
<span class="gp">$ </span>make
</pre></div>
</div>
</section>
<section id="build-bl31-elf">
<h3>build bl31.elf<a class="headerlink" href="#build-bl31-elf" title="Permalink to this heading"></a></h3>
<p>To build bl31.elf we should fetch Fetch sources of ARM Trusted Firmware (ATF) and checkout the tags that
corresponding to the SDK version. Take Vivado 2018.3 for example:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>git<span class="w"> </span>clone<span class="w"> </span>https://github.com/Xilinx/arm-trusted-firmware.git
<span class="gp">$ </span><span class="nb">cd</span><span class="w"> </span>arm-trusted-firmware
<span class="gp">$ </span>git<span class="w"> </span>checkout<span class="w"> </span>xilinx-v2018.3
</pre></div>
</div>
<p>By default, the Arm-trusted firmware builds for OCM space at address 0xFFFEA000, and ATF assume that UBoot
or nuttx.elf located at address 0x08000000. Then we just build bl31.elf with:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>make<span class="w"> </span><span class="nv">CROSS_COMPILE</span><span class="o">=</span>aarch64-none-elf-<span class="w"> </span><span class="nv">PLAT</span><span class="o">=</span>zynqmp<span class="w"> </span><span class="nv">RESET_TO_BL31</span><span class="o">=</span><span class="m">1</span>
</pre></div>
</div>
<p>But, with DEBUG flag set to 1, it can’t fit in OCM, so by default with DEBUG=1, it builds for DDR location
0x1000 with build flag DEBUG=1 mentioned while building. Alternatively, user has always an option to build
for the location of their choice by specifying  the build flags ZYNQMP_ATF_MEM_BASE, ZYNQMP_ATF_MEM_SIZE while
building. The flag ZYNQMP_ATF_MEM_BASE specifies the base address of ATF and flag ZYNQMP_ATF_MEM_SIZE specifies
the maximum size the ATF image can be. what’s more we can specifies the target address of Uboot or nuttx.elf
by PRELOADED_BL33_BASE. for zcu111:nsh configuration Example bl31 build command:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>make<span class="w"> </span><span class="nv">CROSS_COMPILE</span><span class="o">=</span>aarch64-none-elf-<span class="w"> </span><span class="nv">PLAT</span><span class="o">=</span>zynqmp<span class="w"> </span><span class="nv">RESET_TO_BL31</span><span class="o">=</span><span class="m">1</span><span class="w"> </span><span class="nv">ZYNQMP_ATF_MEM_BASE</span><span class="o">=</span>0x10000<span class="w"> </span><span class="nv">ZYNQMP_ATF_MEM_SIZE</span><span class="o">=</span>0x40000<span class="w"> </span><span class="nv">PRELOADED_BL33_BASE</span><span class="o">=</span>0x100000
</pre></div>
</div>
<p>If we don’t dubug bl31 we just build bl31 in following command:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>make<span class="w"> </span><span class="nv">CROSS_COMPILE</span><span class="o">=</span>aarch64-none-elf-<span class="w"> </span><span class="nv">PLAT</span><span class="o">=</span>zynqmp<span class="w"> </span><span class="nv">RESET_TO_BL31</span><span class="o">=</span><span class="m">1</span><span class="w"> </span><span class="nv">PRELOADED_BL33_BASE</span><span class="o">=</span>0x100000
</pre></div>
</div>
<p>After the build process completes the bl31.elf binary is created within the /build/zynqmp/release/bl31 directory.</p>
</section>
<section id="build-zynqmp-pmufw-elf">
<h3>build zynqmp_pmufw.elf<a class="headerlink" href="#build-zynqmp-pmufw-elf" title="Permalink to this heading"></a></h3>
<p>The Platform Management Unit (PMU) in Zynq MPSoC has a Microblaze with 32 KB of ROM and 128 KB of RAM. The ROM is
pre-loaded with PMU Boot ROM (PBR) which performs pre-boot tasks and enters a service mode. For more details on PMU,
PBR and PMUFW load sequence, refer to Platform Management Unit (Chapter-6) in Zynq MPSoC TRM (UG1085). PMU RAM can
be loaded with a firmware (PMU Firmware) at run-time and can be used to extend or customize the functionality of PMU.
Some part of the RAM is reserved for PBR, leaving around 125.7 KB for PMU Firmware.
There are usually two flows to create and build a PMU Firmware image for the target, Xilinx Vitis or Vivado SDK IDE or
hsi command line. The PMU Firmware is provided as a template application for the PMU processor for any hardware platform
including the Zynq MPSoC device. The steps required to create and build it can be applied by selecting the appropriate
platform, processor, and template to create zynqmp_pmufw.elf. We can also create PMU Firmware from system hardware
project hdf file by hsi command line:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>proc generate_pmufw {} {
    if {[file exists pmu_fw/zynqmp_pmufw.elf] != 1} {
        set pmufw_design [hsi::create_sw_design pmu_1 -proc psu_pmu_0 -app zynqmp_pmufw]
        hsi::add_library libmetal
        hsi::generate_app -dir pmu_fw -compile
        return &quot;pmu_fw/zynqmp_pmufw.elf&quot;
    }
    return &quot;pmu_fw/zynqmp_pmufw.elf&quot;
}
</pre></div>
</div>
<p>In order to call this procs, the user needs to open the hdf (hsi::open_hw_design):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>proc create_pmufw {hdf} {
    hsi::open_hw_design $hdf
    set pmufw [generate_pmufw]
    hsi::close_hw_design [hsi::current_hw_design]
}
</pre></div>
</div>
<p>Create a TCL script with HSI commands above -&gt; Create a TCL script with HSI commands above -&gt;
Launch XSCT 2018.3 -&gt; Change directory to the zipped directory -&gt; source xsct_script.tcl -&gt;
create_pmufw design_1_wrapper.hdf</p>
</section>
<section id="build-zynqmp-fsbl-elf">
<h3>build zynqmp_fsbl.elf<a class="headerlink" href="#build-zynqmp-fsbl-elf" title="Permalink to this heading"></a></h3>
<p>First Stage Bootloader (FSBL) for Zynq UltraScale+ MPSoC configures the FPGA with hardware bitstream (if it exists)
and loads the Operating System (OS) Image or Standalone (SA) Image or 2nd Stage Boot Loader image from the non-volatile
memory (SD/eMMC/QSPI) to Memory (DDR/TCM/OCM) and takes A53/R5 out of reset. It supports multiple partitions, and each
partition can be a code image or a bitstream. Each of these partitions, if required, will be authenticated and/or decrypted.
FSBL is loaded into OCM and handed off by CSU BootROM after authenticating and/or decrypting (as required) FSBL.
There are usually two flows to create and build a PMU Firmware image for the target, Xilinx Vitis or Vivado SDK IDE or
hsi command line.
To create FSBL by Vitis or Vivado SDK IDE just launch VITIS or Vivado SDK and do following flow:</p>
<ul class="simple">
<li><p>Provide path where VITIS workspace and project need to be created. With this VITIS workspace will be created</p></li>
<li><p>(Optional step) To work with local repos, Select “Xilinx” (ALT - x) -&gt; Repositories. Against Local Repositories,
click on “New…” and provide path of the local repo</p></li>
<li><p>Select File–&gt;New–&gt;Application Project to open “New Project” window, provide name for FSBL project</p></li>
<li><dl class="simple">
<dt>In the “Platform” section, click on “Create a new platform from hardware (XSA)” and select pre-defined hardware platform for ZynqMP.</dt><dd><ul>
<li><p>Alternatively, to create a new/custom platform from a .xsa file, click on “+”, browse and select the XSA file and a new hardware platform is created.</p></li>
</ul>
</dd>
</dl>
</li>
<li><p>In the “Domain” window, select the processor psu_cortexa53_0/psu_cortexr5_0, OS as standalone and Language as C.</p></li>
<li><p>Click Next and select “Zynq MP FSBL”</p></li>
<li><p>Click “Finish” to generate the A53/R5 FSBL. This populates the FSBL code and also builds it (along with BSP)</p></li>
<li><dl class="simple">
<dt>Debug prints in FSBL are now disabled by default. To enable debug prints, define symbol: FSBL_DEBUG_INFO.</dt><dd><ul>
<li><p>In VITIS this can be done by: right click on FSBL application project -&gt; select “C/C++ Build Settings” -&gt; “Tool Settings” tab -&gt; Symbols (under ARM v8 gcc compiler)</p></li>
<li><p>Click on Add (+) icon and Enter Value: FSBL_DEBUG_INFO, click on “OK” to close the “Enter Value” screen</p></li>
</ul>
</dd>
</dl>
</li>
<li><p>In case any of the source files (FSBL or BSP) need to be modified, browse the file, make the change and save the file,
build the project. elf file will be present in the Debug/Release folder of FSBL project.</p></li>
</ul>
<p>To create FSBL by XSCT command line just launch XSCT console and execute following TCL script with HSI commands:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>proc generate_fsbl {} {
    if {[file exists zynqmp_fsbl/zynqmp_fsbl.elf] != 1} {
        set fsbl_design [hsi::create_sw_design fsbl_1 -proc psu_cortexa53_0 -app zynqmp_fsbl]
        common::set_property APP_COMPILER &quot;aarch64-none-elf-gcc&quot; $fsbl_design
        common::set_property -name APP_COMPILER_FLAGS -value &quot;-DRSA_SUPPORT -DFSBL_DEBUG_INFO -DXPS_BOARD_ZCU111&quot; -objects $fsbl_design
        hsi::add_library libmetal
        hsi::generate_app -dir zynqmp_fsbl -compile
    }
    return &quot;zynqmp_fsbl/zynqmp_fsbl.elf&quot;
}
</pre></div>
</div>
<p>In order to call this procs, the user needs to open the hdf (hsi::open_hw_design):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>proc create_fsbl {hdf} {
    hsi::open_hw_design $hdf
    set fsbl [generate_fsbl]
    hsi::close_hw_design [hsi::current_hw_design]
}
</pre></div>
</div>
<p>Create a TCL script with HSI commands above -&gt; Create a TCL script with HSI commands above -&gt;
Launch XSCT 2018.3 -&gt; Change directory to the zipped directory -&gt; source xsct_script.tcl -&gt;
create_fsbl design_1_wrapper.hdf</p>
</section>
<section id="generate-boot-bin-image">
<h3>generate BOOT.bin image<a class="headerlink" href="#generate-boot-bin-image" title="Permalink to this heading"></a></h3>
<p>You can create BOOT.bin images using the BIF attributes and the Bootgen command.
For this configuration, the BIF file(named fsbl.bif) contains the following attributes:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>the_ROM_image:
{
  [fsbl_config]a53_x64
  [bootloader]zynqmp_fsbl.elf
  [pmufw_image]zynqmp_pmufw.elf
  [destination_cpu = a53-0, exception_level = el-3, trustzone]bl31.elf
  [destination_cpu = a53-0, exception_level = el-1]nuttx.elf
}
</pre></div>
</div>
<p>The Vitis IDE calls the following Bootgen command to generate the BOOT.bin image for this configuration:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>bootgen -image fsbl.bif -arch zynqmp -o .\BOOT.bin
</pre></div>
</div>
</section>
<section id="flash-boot-bin-to-qspi-flash">
<h3>Flash BOOT.bin to QSPI FLASH<a class="headerlink" href="#flash-boot-bin-to-qspi-flash" title="Permalink to this heading"></a></h3>
<p>We can flash BOOT.bin into QSPI FLASH in following flow:</p>
<ul class="simple">
<li><p>In the Vivado SDK/Vitis IDE, select Xilinx -&gt; Program Flash.</p></li>
<li><p>In the Program Flash wizard, browse to and select the BOOT.bin image file that was created as a part of this example.</p></li>
<li><p>Select <strong>qspi-x8-dual_parallel</strong> as the Flash type.</p></li>
<li><p>Set the Offset as 0 and select the BOOT.bin file.</p></li>
<li><p>Click Program to start the process of programming the QSPI flash with the BOOT.bin.</p></li>
<li><p>Wait until you see the message “Flash Operation Successful” in the console.</p></li>
</ul>
<p>Set mode switch SW6 to QSPI32, NuttX will appear in the Serial Console when we power on zcu111.</p>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="../../index.html" class="btn btn-neutral float-left" title="Zynq UltraScale+ MPSoC" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="../../../../avr/index.html" class="btn btn-neutral float-right" title="Microchip AVR" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, The Apache Software Foundation.</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>