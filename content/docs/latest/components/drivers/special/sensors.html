<!--
 Documentation/_templates/layout.html

 Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.  The
 ASF licenses this file to you under the Apache License, Version 2.0 (the
 "License"); you may not use this file except in compliance with the
 License.  You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 License for the specific language governing permissions and limitations
 under the License.
-->

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Sensor Drivers &mdash; NuttX latest documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/copybutton.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/tabs.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/sphinx_highlight.js"></script>
        <script src="../../../_static/clipboard.min.js"></script>
        <script src="../../../_static/copybutton.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="Segger RTT drivers" href="segger.html" />
    <link rel="prev" title="rwbuffer.c" href="rwbuffer.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
  
    <a href="../../../index.html" class="icon icon-home"> NuttX
  

  
  </a>

  <!-- this version selector is quite ugly, should be probably replaced by something
       more modern -->

  <div class="version-selector">
    <select onchange="javascript:location.href = this.value;">
    
    <option value="../../../../latest" selected="selected">latest</option>
    
    <option value="../../../../10.0.0" >10.0.0</option>
    
    <option value="../../../../10.0.1" >10.0.1</option>
    
    <option value="../../../../10.1.0" >10.1.0</option>
    
    <option value="../../../../10.2.0" >10.2.0</option>
    
    <option value="../../../../10.3.0" >10.3.0</option>
    
    <option value="../../../../11.0.0" >11.0.0</option>
    
    <option value="../../../../12.0.0" >12.0.0</option>
    
    <option value="../../../../12.1.0" >12.1.0</option>
    
    <option value="../../../../12.2.0" >12.2.0</option>
    
    <option value="../../../../12.2.1" >12.2.1</option>
    
    <option value="../../../../12.3.0" >12.3.0</option>
    
    <option value="../../../../12.4.0" >12.4.0</option>
    
    <option value="../../../../12.5.0" >12.5.0</option>
    
    <option value="../../../../12.5.1" >12.5.1</option>
    
    </select>
  </div>

  
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Table of Contents</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../../index.html">Home</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../introduction/index.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../quickstart/index.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contributing/index.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../introduction/inviolables.html">The Inviolable Principles of NuttX</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../platforms/index.html">Supported Platforms</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../index.html">OS Components</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../../binfmt.html">Binary Loader</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../index.html">Device Drivers</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../character/index.html">Character Device Drivers</a></li>
<li class="toctree-l3"><a class="reference internal" href="../block/index.html">Block Device Drivers</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="index.html">Specialized Device Drivers</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="audio.html">Audio Device Drivers</a></li>
<li class="toctree-l4"><a class="reference internal" href="clk.html">Clock management (CLK)</a></li>
<li class="toctree-l4"><a class="reference internal" href="devicetree.html">Device Tree support</a></li>
<li class="toctree-l4"><a class="reference internal" href="dma.html">DMA Drivers</a></li>
<li class="toctree-l4"><a class="reference internal" href="framebuffer.html">Frame Buffer Drivers</a></li>
<li class="toctree-l4"><a class="reference internal" href="i2c.html">I2C Device Drivers</a></li>
<li class="toctree-l4"><a class="reference internal" href="ioexpander.html">IO Expander Device Drivers</a></li>
<li class="toctree-l4"><a class="reference internal" href="lcd.html">LCD Character Drivers</a></li>
<li class="toctree-l4"><a class="reference internal" href="mtd.html">Memory Technology Device Drivers</a></li>
<li class="toctree-l4"><a class="reference internal" href="regmap.html">drivers/regmap</a></li>
<li class="toctree-l4"><a class="reference internal" href="reset.html">Reset Driver</a></li>
<li class="toctree-l4"><a class="reference internal" href="rptun.html">Remote Proc Tunnel Drivers</a></li>
<li class="toctree-l4"><a class="reference internal" href="rwbuffer.html"><code class="docutils literal notranslate"><span class="pre">rwbuffer.c</span></code></a></li>
<li class="toctree-l4 current"><a class="current reference internal" href="#">Sensor Drivers</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#adxl345">ADXL345</a></li>
<li class="toctree-l5"><a class="reference internal" href="#adxl372">ADXL372</a></li>
<li class="toctree-l5"><a class="reference internal" href="#lsm330-spi">LSM330_SPI</a></li>
<li class="toctree-l5"><a class="reference internal" href="#mpl115a">MPL115A</a></li>
<li class="toctree-l5"><a class="reference internal" href="#common-sensor-register-interface">Common Sensor Register Interface</a></li>
<li class="toctree-l5"><a class="reference internal" href="#sensor-cluster-driver-interface">Sensor Cluster Driver Interface</a></li>
<li class="toctree-l5"><a class="reference internal" href="#adt7320">ADT7320</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="segger.html">Segger RTT drivers</a></li>
<li class="toctree-l4"><a class="reference internal" href="spi.html">SPI Device Drivers</a></li>
<li class="toctree-l4"><a class="reference internal" href="syslog.html">SYSLOG</a></li>
<li class="toctree-l4"><a class="reference internal" href="sdio.html">SDIO Device Drivers</a></li>
<li class="toctree-l4"><a class="reference internal" href="usbdev.html">USB Device-Side Drivers</a></li>
<li class="toctree-l4"><a class="reference internal" href="usbhost.html">USB Host-Side Drivers</a></li>
<li class="toctree-l4"><a class="reference internal" href="usbmisc.html">USB Miscellaneous Drivers</a></li>
<li class="toctree-l4"><a class="reference internal" href="usbmonitor.html">USB Monitor support</a></li>
<li class="toctree-l4"><a class="reference internal" href="usrsock.html">Usrsock Driver</a></li>
<li class="toctree-l4"><a class="reference internal" href="mmcsd.html">MMCSD Device Drivers</a></li>
<li class="toctree-l4"><a class="reference internal" href="net/index.html">Network interface drivers</a></li>
<li class="toctree-l4"><a class="reference internal" href="pipes.html">FIFO and named pipe drivers</a></li>
<li class="toctree-l4"><a class="reference internal" href="power/index.html">Power-related Drivers</a></li>
<li class="toctree-l4"><a class="reference internal" href="virtio.html">Virtio Device Drivers</a></li>
<li class="toctree-l4"><a class="reference internal" href="video.html">Video Device Drivers</a></li>
<li class="toctree-l4"><a class="reference internal" href="wireless.html">Wireless Drivers</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../index.html#lower-half-and-upper-half">Lower-half and upper-half</a></li>
<li class="toctree-l3"><a class="reference internal" href="../index.html#subdirectories-of-nuttx-drivers">Subdirectories of <code class="docutils literal notranslate"><span class="pre">nuttx/drivers</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../index.html#skeleton-files">Skeleton Files</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../nxflat.html">NXFLAT</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../nxgraphics/index.html">NX Graphics Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../paging.html">On-Demand Paging</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../audio/index.html">Audio Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../filesystem/index.html">NuttX File System</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../libs/index.html">NuttX libraries</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../net/index.html">Network Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../mm/index.html">Memory Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../syscall.html">Syscall Layer</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../tools/index.html"><code class="docutils literal notranslate"><span class="pre">/tools</span></code> Host Tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../arch/index.html">Architecture-Specific Code</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../boards.html">Boards Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../cmake.html">CMake Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../openamp.html">OpenAMP Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../video.html">Video Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../crypto.html">Crypto API Subsystem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../wireless.html">Wireless Subsystem</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../applications/index.html">Applications</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../implementation/index.html">Implementation Details</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../reference/index.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../faq/index.html">FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../guides/index.html">Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../glossary.html">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../logos/index.html">NuttX Logos</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">NuttX</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">OS Components</a></li>
          <li class="breadcrumb-item"><a href="../index.html">Device Drivers</a></li>
          <li class="breadcrumb-item"><a href="index.html">Specialized Device Drivers</a></li>
      <li class="breadcrumb-item active">Sensor Drivers</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../_sources/components/drivers/special/sensors.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>this list is incomplete. See drivers/sensors for ar full list of
supported sensors</p>
</div>
<section id="sensor-drivers">
<h1>Sensor Drivers<a class="headerlink" href="#sensor-drivers" title="Permalink to this heading"></a></h1>
<section id="adxl345">
<h2>ADXL345<a class="headerlink" href="#adxl345" title="Permalink to this heading"></a></h2>
<p>Contributed by Alan Carvalho de Assis</p>
<p>The ADXL345 accelerometer can operate in I2C or SPI mode. To operate in I2C
mode just connect the CS pin to Vddi/o.</p>
<p>In order to operate in SPI mode CS need to use connected to microcontroller,
it cannot leave unconnected.</p>
<p>In SPI mode it works with clock polarity (CPOL) = 1 and clock phase (CPHA)
= 1.</p>
</section>
<section id="adxl372">
<h2>ADXL372<a class="headerlink" href="#adxl372" title="Permalink to this heading"></a></h2>
<p>Contributed by Bob Feretich</p>
<p>The ADXL372 is a 200g tri-axis accelerometer that is capable of detecting
and recording shock impact impact events. Recording trigger
characteristics are programmed into the sensor via multiple threshold and
duration registers.  The ADXL372 is a SPI only device that can transfer
data at 10 MHz.  The data transfer performance of this part permits the
sensor to be sampled “on demand” rather than periodically sampled by a
worker task.</p>
<p>See the description of the “Common Sensor Register Interface” below for more
details. It also implements the “Sensor Cluster Driver Interface”.</p>
</section>
<section id="lsm330-spi">
<h2>LSM330_SPI<a class="headerlink" href="#lsm330-spi" title="Permalink to this heading"></a></h2>
<p>Contributed by Bob Feretich</p>
<p>The LSM330 consists of a multi-range tri-axis accelerometer and a
multi-range tri-axis gyroscope. The tri-axis accelerometer features two
state machines that can be firmware programmed for event detection. The
tri-axis gyroscope features threshold and duration registers for event
detection.</p>
<p>This driver supports the LSM330 in SPI mode. In this mode, the LSM330
that can transfer data at 10 MHz. The data transfer performance of
this part permits the sensor to be sampled “on demand” rather than
periodically sampled by a worker task. See the description of the “Common
Sensor Register Interface” below for more details. It also implements the
“Sensor Cluster Driver Interface”.</p>
</section>
<section id="mpl115a">
<h2>MPL115A<a class="headerlink" href="#mpl115a" title="Permalink to this heading"></a></h2>
<p>Contributed by Alan Carvalho de Assis</p>
<p>This driver has support only for MPL115A1 (SPI), but support to MPL115A2
(I2C) can be added easily.</p>
</section>
<section id="common-sensor-register-interface">
<h2>Common Sensor Register Interface<a class="headerlink" href="#common-sensor-register-interface" title="Permalink to this heading"></a></h2>
<p>Contributed by Bob Feretich</p>
<p>Background and problem statement:</p>
<p>The capabilities and performance of modern sensors have grown tremendously.
Most sensors are now capable of some degree of autonomous behavior and
several permit the user to load firmware into them and perform as
nanocontrollers.  Other sensors have very sophisticated built-in digital
filters that can be programmed with hundreds of parameters.</p>
<p>Currently most sensor drivers in the NuttX drivers/sensors
directory implement file_ops open(), close(), and read() functions.
The open() function initializes the sensor and places it in a mode where
it can transfer live data in a default configuration. The close() function
places the sensor in a low power shutdown mode. The read() function
returns the most recent data sample from the sensor’s most used data
output registers.  The write() function is rarely implemented and when it
is there is no consistency in its use. The lseek() and poll() functions
seem to be completely ignored.  This results in the sensors being operated
in only their most primitive modes using a fixed “default configuration”.</p>
<p>To work around this problem sensor drivers have implemented ioctl()
functions to perform configuration, program the sensor, and manage
autonomous activity.  Ioctls provide a method where user programs can
tunnel through a high level driver to access and control device specific
features. The problem with using ioctls is that before the ioctl interface
can be used, the sensor driver must be opened; and the open() function
causes the driver to start performing these primitive actions, so before
ioctls can manage the drivers as desired, ioctls must first be used to
undo the generic actions caused by the open() function. Another major
issue is that there is no consistency from sensor to sensor on ioctl
definitions, not even for the most common sensor actions like writing a
sensor control register or reading a sensor status register.</p>
<p>Purpose:</p>
<p>The purpose of the “Common Sensor Register Interface” is to implement a
consistent and more useful definition of file_ops interface and to make the
file_ops open() function more flexible in establishing the initial
operational state of the sensor. Compatibility for user applications that
implement the current open(), close(), read() interface will be
maintained; and the much greater capabilities of modern sensors will
become accessible through this interface.</p>
<p>Scope:</p>
<p>Applicable to I2C and SPI attached sensors, and some serial port attached
sensors.</p>
<p>The file_ops interface definition:</p>
<p>open(): This function performs the below actions…</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Reads the sensors ID register. If the sensor responds with an
unexpected value, then…</p>
<ol class="loweralpha simple">
<li><p>The driver’s write() function is disabled.</p></li>
<li><p>The open function initializes the driver instance, so
that read() and lseek() operations may be performed to enable
problem diagnoses, but the sensor hardware is not initialized.
(No write operations are performed to the sensor.)</p></li>
<li><p>The errno global variable is set to positive ENODEV
(“No such device”).</p></li>
<li><dl class="simple">
<dt>The open() function returns successfully with a file_handle.</dt><dd><p>Note that the calling routine should clear errno before
calling open(). (The file_ops rules prevent drivers from
setting errno to zero.)</p>
</dd>
</dl>
</li>
</ol>
</li>
<li><p>The other file_ops functions are enabled.</p></li>
<li><p>The driver’s “current reg address” state variable is set to the
sensor’s first sensor data output register. (This will make
calls to read() return live sensor data and maintain compatibility
with existing user programs.)</p></li>
<li><p>If the driver supports a default worker task and an interrupt
handler is specified by in the sensor configuration structure, then
the default worker task is bound to the default worker task.</p></li>
<li><p>The sensor configuration structure (that was provided to the driver
registration function) is examined to determine whether a custom
sensor configuration is specified. (The custom configuration is
basically an array of (device_reg_address, value) pairs that are
written to the sensor via “single register write” operations.
If a custom sensor configuration was specified, then that
configuration is written to the sensor, otherwise the “default
sensor configuration” is written to the sensor.
(A side effect of writing this data may result in interrupts
occurring and data being transferred to/from the worker task.)</p></li>
<li><p>The open() function returns successfully with a file_handle.</p></li>
</ol>
</div></blockquote>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">close()</span></code>: This function stops sensor activity and places it in a low</dt><dd><p>power mode. The file_ops interface functions are disabled for this
instance of the sensor driver. (Except for open())</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">read()</span></code>: The action of this function is dependent on whether a “default</dt><dd><p>worker task” is running and the value of the driver’s “current reg
address” state variable.</p>
<p>If a “default worker task” is running,</p>
<blockquote>
<div><dl class="simple">
<dt>AND the driver’s “current reg address” is equal to the value of</dt><dd><p>the first sensor data output register,</p>
</dd>
<dt>AND the number of bytes to be read is less than or equal to the</dt><dd><p>number of bytes in a “default worker task” sample,</p>
</dd>
</dl>
</div></blockquote>
<p>Then data is copied from the “default worker task’s” sample memory to
the caller’s provided buffer.</p>
<p>Otherwise, this function transfers data from sensor registers to the
data buffer provided by the caller. The first byte read is from the
sensor register address specified by the sensor’s “current reg
address”. The addresses of subsequent bytes to be read are context
sensitive. If more than bus transfer is needed to complete the read,
then a “multi-byte” (sometimes called “burst mode”) data transfer
will be used to fill the buffer.
See the sensor’s datasheet to determine the auto-increment
behavior of a “multi-byte” data transfers.</p>
<p>Note: That most sensors collect only a few bytes of data per sample.
Small data transfers occurring over a high speed bus (like SPI and some
high speed i2c and serial interfaces) are much more efficient when
collected directly from the sensor hardware than by using a worker task
as an intermediary.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">write()</span></code>:  This function transfers data from the data buffer provided by</dt><dd><p>the caller to sensor registers.  The first byte written is to the
sensor register address specified by the sensor’s “current reg
address”.  The addresses of subsequent bytes to be read are context
sensitive.  If more than bus transfer is needed to complete the write,
then a “multi-byte” (sometimes called “burst mode”) data
transfer will be used to transfer data from the buffer.</p>
<p>See the sensor’s datasheet to determine the auto-increment
behavior of a “multi-byte” data transfers.</p>
<p>Note: If write() function was disabled, then no writes will be performed
and the function will return 0 (characters transferred) and errno
is set to -EROFS (“read-only file system”).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">lseek()</span></code>: This function sets the value of the sensor’s “current reg address”</dt><dd><p>(seek_address). The open() function initializes the “current reg address”
to the first sensor data output register, so unless the user needs
to change the sensor configuration, lseek() does not need to be
called. Neither read() nor write() change the sensor’s “current reg
address”.</p>
<p>The definition of lseek is…:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>off_t lseek(int fd, off_t offset, int whence);
</pre></div>
</div>
<p>For whence == SEEK_SET, the sensor’s “current reg address” will be set
to offset.</p>
<p>For whence == SEEK_CUR, offset will be added to the sensor’s “current
reg address”.</p>
<p>For whence == SEEK_END, offset is ignored and the sensor’s “current
reg address” is set to the first sensor data output register.</p>
<p>lseek() will return an error if the resulting “current reg address”
is invalid for the sensor.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ioctl()</span></code>: Ioctls() may still be used and this interface make no attempt to</dt><dd><p>regulate them. But, it is expected that far fewer ioctls will be needed.</p>
</dd>
</dl>
<p>The above interface can be used to fully configure a sensor to the needs
of an application, including the ability to load firmware into sensor
state machines</p>
</section>
<section id="sensor-cluster-driver-interface">
<h2>Sensor Cluster Driver Interface<a class="headerlink" href="#sensor-cluster-driver-interface" title="Permalink to this heading"></a></h2>
<p>Contributed by Bob Feretich</p>
<p>Background and problem statement:</p>
<p>Most microcontrollers can support SPI bus transfers at 8 MHz or greater.
Most SPI attached sensors can support a 10 MHz SPI bus.  Most tri-axis
accelerometers, tri-axis gyroscopes, or tri-axis magnetometers use only 6
bytes per sample. Many sensors use less than 6 bytes per sample.  On an 8
MHz SPI bus it takes about 8 microseconds to transfer a 6 byte sample.
(This time includes a command byte, 6 data bytes, and chip select select
setup and hold.) So, for the below discussion keep in mind that the sensor
sample collection work we want to perform should ideally take 8 microseconds
per sample.</p>
<p>The drivers in the drivers/sensors directory support only the user space
file_ops interface (accessing drivers through the POSIX open/read/close
functions using a file descriptor). Also these drivers typically start
their own worker task to perform sensor data collection, even when their
sensors only transfer a few bytes of data per sample and those transfers
are being made over a high performance bus.</p>
<p>Using the current implementation…</p>
<ol class="arabic simple">
<li><p>A sensor “data ready” or timer interrupt occurs.</p></li>
<li><p>Context is saved and and the driver’s interrupt handler is scheduled
to run.</p></li>
<li><p>The NuttX scheduler dispatches the driver’s interrupt handler task.</p></li>
<li><p>The driver’s interrupt handler task posts to a semaphore that the
driver’s worker task is waiting on.</p></li>
<li><p>NuttX restores the context for the driver’s worker task and starts it
running.</p></li>
<li><p>The driver’s worker task starts the i/o to collect the sample.) (This is
where the 8 microseconds of real work gets performed.) And waits on a
SPI data transfer complete semaphore.</p></li>
<li><p>The NuttX saves the context of the driver’s worker task, and the
scheduler dispatches some other task to run while we are waiting.
Note that this is a good thing. This task is probably performing some
other real work. We want this to happen during the data transfer.</p></li>
<li><p>The completion of the data transfer causes an interrupt. NuttX saves the
current context and restores the driver’s worker task’s context.</p></li>
<li><p>The driver’s worker task goes to sleep waiting on the semaphore for the
next sensor “data ready” or timer interrupt.</p></li>
<li><p>The NuttX saves the context of the driver’s worker task, and the
scheduler dispatches some other task to run while we are waiting.</p></li>
</ol>
<p>Independently with the above…</p>
<ol class="loweralpha simple">
<li><p>The sensor application program performs a file_ops read() to collect a
sample.</p></li>
<li><p>The NuttX high level driver receives control, performs a thin layer of
housekeeping and calls the sensor driver’s read function.</p></li>
<li><p>The sensor driver’s read function copies the most recent sample from the
worker task’s data area to the application’s buffer and returns.</p></li>
<li><p>The NuttX high level driver receives control, performs a thin layer of
housekeeping and returns.</p></li>
<li><p>The application processes the sample.</p></li>
</ol>
<p>Using a 216 MHz STM32F7 with no other activity occurring, we have timed the
above the elapsed time for the above to be on average 45 microseconds.</p>
<p>Most sensor applications process data from multiple sensors. (An 9-DoF IMU
is typically represented as three sensors (accelerometer, gyroscope, and
magnetometer). In this case there are three copies of 1-10 occurring in
parallel.</p>
<p>In applications where live data is being used, the context switch
thrashing and cache pollution of this approach cripples system
performance.  In applications where sensor FIFO data is being used and
therefore a large amount of data is collected per iteration, the non “zero
copy” nature of the data collection becomes a performance issue.</p>
<p>Purpose:</p>
<p>The “Sensor Cluster Driver Interface” provides a standard mechanism for
an application to collect data from multiple sensor drivers in a much more
efficient manner. It significantly reduces the number of running tasks and
the context thrashing and cache pollution caused by them. It also permits
“zero copy” collection of sensor data.</p>
<p>The Sensor Cluster Driver Interface uses a single “worker task” to be shared
by an arbitrary number of drivers. This shared worker task is a kernel
task that is registered like a driver, supports a driver interface to
application programs, and collects data from multiple sensors (a cluster of
sensors), we refer to it a “Sensor Cluster Driver”.</p>
<p>Its goal is to change the sequence of events detailed above to…</p>
<ol class="arabic simple">
<li><p>A sensor “data ready” or timer interrupt occurs.</p></li>
<li><p>Context is saved and and the cluster driver’s interrupt handler is
scheduled to run.</p></li>
<li><p>The NuttX scheduler dispatches the cluster driver’s interrupt handler
task.</p></li>
<li><p>The cluster driver’s interrupt handler task posts to a semaphore that
the cluster driver’s worker task is waiting on.</p></li>
<li><p>NuttX restores the context for the driver’s worker task and starts it
running.</p></li>
<li><p>The cluster driver’s worker task starts the i/o to collect the sample.
There are two choices here. Programmed I/O (PIO) or DMA. If PIO is
fastest for a small sample size, but it will lock up the processor for
the full duration of the transfer; it can only transfer from one
sensor at a time; and the worker task should manually yield control
occasionally to permit other tasks to run. DMA has higher start and
completion overhead, but it is much faster for long transfers, can
perform simultaneous transfers from sensors on different buses, and
automatically releases the processor while the transfer is occurring.
For this reason our drivers allows the worker task to choose between
PIO (driver_read()) and DMA (driver_exchange()), a common extension to
the sensor_cluster_operations_s structure. So either way after one or
more transfers we yield control and move to the next step. Note that
the data is being transferred directly into the buffer provided by the
application program; so no copy needs to be performed.</p></li>
<li><p>The NuttX saves the context of the cluster driver’s worker task, and the
scheduler dispatches some other task to run while we are waiting.
Again note that this is a good thing. This task is probably performing
some other real work. We want this to happen during the data transfer.</p></li>
<li><p>The completion of the last of the previous data transfers causes an
interrupt.  NuttX saves the current context and restores the cluster
driver’s worker task’s context. If there is more sensor data to
collect, then goto Step 6.  Otherwise it posts to a semaphore that
will wake the application.</p></li>
<li><p>The driver’s worker task goes to sleep waiting on the semaphore for the
next sensor “data ready” or timer interrupt.</p></li>
<li><p>The NuttX saves the context of the driver’s worker task, and the
scheduler dispatches some other task to run while we are waiting.</p></li>
</ol>
<p>Independently with the above…</p>
<ol class="loweralpha simple">
<li><p>The sensor application program performs a file_ops read() to collect a
sample.</p></li>
<li><p>The NuttX high level driver receives control, performs a thin layer of
housekeeping and calls the sensor driver’s read function.</p></li>
<li><p>The sensor driver’s read function copies the most recent sample from the
worker task’s data area to the application’s buffer and returns.</p></li>
<li><p>The NuttX high level driver receives control, performs a thin layer of
housekeeping and returns.</p></li>
<li><p>The application processes the sample.</p></li>
</ol>
<p>So when collecting data from three sensors, this mechanism saved…</p>
<ul class="simple">
<li><p>the handling of 2 sensor “data ready” or timer interrupts (Steps 1 - 4).</p></li>
<li><p>2 occurrences of waking and scheduling of a worker task (Step 5).</p></li>
<li><p>2 context switches to other tasks (Step 9 &amp; 10)</p></li>
<li><p>if the three sensors were on separate buses, then 2 occurrences of</p></li>
</ul>
<p>Steps 6 - 8 could have also been saved.</p>
<ul class="simple">
<li><p>An extra copy operation of the collected sensor data.</p></li>
<li><p>The cache pollution caused by 2 competing worker tasks.</p></li>
</ul>
<p>Definitions:</p>
<dl class="simple">
<dt>“Leaf Driver” - a kernel driver that implements the “Sensor Cluster Driver</dt><dd><p>Interface” so that it can be called by Cluster drivers.</p>
</dd>
<dt>“Cluster Driver” - a kernel driver that uses the “Sensor Cluster Driver</dt><dd><p>Interface” to call leaf drivers.</p>
</dd>
<dt>“Entry-Point Vector” - an array of function addresses to which a leaf driver</dt><dd><p>will permit calls by a Cluster Driver.</p>
</dd>
<dt>“Leaf Driver Instance Handle” - a pointer to an opaque Leaf Driver structure</dt><dd><p>that identifies an instance of the leaf driver. Leaf Drivers store this
handle in its configuration structure during registration.</p>
</dd>
</dl>
<p>Sensor Cluster Interface description:</p>
<ul class="simple">
<li><p>The definition of an entry-point vector. This is similar to the
entry-point vector that is provided to the file-ops high level driver.
This entry-point vector must include the sensor_cluster_operations_s
structure as its first member.</p></li>
<li><p>The the definition of an driver entry-point vector member in the leaf
driver’s configuration structure. The leaf driver registration function
must store the address of its entry-point vector in this field.</p></li>
<li><p>The the definition of an instance handle member in the leaf drivers
configuration structure. The leaf driver registration function must store
a handle (opaque pointer) to the instance of the leaf driver being
registered in this field. Note that this should be the same handle that
the leaf driver supplies to NuttX to register itself. The cluster driver
will include this handle as a parameter in calls made to the leaf driver.</p></li>
</ul>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">sensor_cluster_operations_s</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">CODE</span><span class="w"> </span><span class="nf">int</span><span class="w">     </span><span class="p">(</span><span class="o">*</span><span class="n">driver_open</span><span class="p">)(</span><span class="n">FAR</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">instance_handle</span><span class="p">,</span><span class="w"> </span><span class="kt">int32_t</span><span class="w"> </span><span class="n">arg</span><span class="p">);</span>
<span class="w">  </span><span class="n">CODE</span><span class="w"> </span><span class="nf">int</span><span class="w">     </span><span class="p">(</span><span class="o">*</span><span class="n">driver_close</span><span class="p">)(</span><span class="n">FAR</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">instance_handle</span><span class="p">,</span><span class="w"> </span><span class="kt">int32_t</span><span class="w"> </span><span class="n">arg</span><span class="p">);</span>
<span class="w">  </span><span class="n">CODE</span><span class="w"> </span><span class="nf">ssize_t</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">driver_read</span><span class="p">)(</span><span class="n">FAR</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">instance_handle</span><span class="p">,</span><span class="w"> </span><span class="n">FAR</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
<span class="w">                              </span><span class="kt">size_t</span><span class="w"> </span><span class="n">buflen</span><span class="p">);</span>
<span class="w">  </span><span class="n">CODE</span><span class="w"> </span><span class="nf">ssize_t</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">driver_write</span><span class="p">)(</span><span class="n">FAR</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">instance_handle</span><span class="p">,</span>
<span class="w">                               </span><span class="n">FAR</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">buflen</span><span class="p">);</span>
<span class="w">  </span><span class="n">CODE</span><span class="w"> </span><span class="nf">off_t</span><span class="w">   </span><span class="p">(</span><span class="o">*</span><span class="n">driver_seek</span><span class="p">)(</span><span class="n">FAR</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">instance_handle</span><span class="p">,</span><span class="w"> </span><span class="kt">off_t</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span>
<span class="w">                              </span><span class="kt">int</span><span class="w"> </span><span class="n">whence</span><span class="p">);</span>
<span class="w">  </span><span class="n">CODE</span><span class="w"> </span><span class="nf">int</span><span class="w">     </span><span class="p">(</span><span class="o">*</span><span class="n">driver_ioctl</span><span class="p">)(</span><span class="n">FAR</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">instance_handle</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">cmd</span><span class="p">,</span>
<span class="w">                               </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">arg</span><span class="p">);</span>
<span class="w">  </span><span class="n">CODE</span><span class="w"> </span><span class="nf">int</span><span class="w">     </span><span class="p">(</span><span class="o">*</span><span class="n">driver_suspend</span><span class="p">)(</span><span class="n">FAR</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">instance_handle</span><span class="p">,</span><span class="w"> </span><span class="kt">int32_t</span><span class="w"> </span><span class="n">arg</span><span class="p">);</span>
<span class="w">  </span><span class="n">CODE</span><span class="w"> </span><span class="nf">int</span><span class="w">     </span><span class="p">(</span><span class="o">*</span><span class="n">driver_resume</span><span class="p">)(</span><span class="n">FAR</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">instance_handle</span><span class="p">,</span><span class="w"> </span><span class="kt">int32_t</span><span class="w"> </span><span class="n">arg</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Note that the sensor_cluster_operations_s strongly resembles the NuttX fs.h
file_operations structures. This permits the current file_operations
functions to become thin wrappers around these functions.</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">driver_open()</span></code> Same as the fs.h open() except that arg can be specify</dt><dd><p>permitting more flexibility in sensor configuration and initial operation.
when arg = 0 the function of driver_open() must be identical to open().</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">driver_close()</span></code> Same as the fs.h close() except that arg can be specify</dt><dd><p>permitting more flexibility in selecting a sensor low power state.
when arg = 0 the function of driver_close() must be identical to close().</p>
</dd>
</dl>
<p><code class="docutils literal notranslate"><span class="pre">driver_read()</span></code> Same as the fs.h read().</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">driver_write()</span></code> Same as the fs.h write(). Optional. Set to NULL if not</dt><dd><p>supported.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">driver_seek()</span></code> Same as the fs.h seek(). Optional. Set to NULL if not</dt><dd><p>supported.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">driver_ioctl()</span></code> Same as the fs.h ioctl(). Optional. Set to NULL if not</dt><dd><p>supported.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">driver_suspend()</span></code> and <code class="docutils literal notranslate"><span class="pre">driver_resume()</span></code> Optional. Set to NULL if not</dt><dd><p>supported.  It is common for sensor applications to conserve power and
send their microcontroller into a low power sleep state. It seems
appropriate to reserve these spots for future use. These driver entry
points exist in Linux and Windows. Since microcontrollers and sensors
get more capable every year, there should soon be a requirement for
these entry points.  Discussion on how to standardize their use and
implementation should
be taken up independently from this driver document.</p>
</dd>
</dl>
<p>Note that all drivers are encouraged to extend their entry-point vectors
beyond this common segment. For example it may be beneficial for the
worker task  to select between programmed i/o and DMA data transfer
routines. Unregulated extensions to the Entry-Point Vector should be
encouraged to maximize the benefits of a sensor’s features.</p>
<p>Operation:</p>
<p>Board logic (configs directory) will register the cluster driver. The
cluster driver will register the leaf drivers that it will call.
This means that the cluster driver has access to the leaf driver’s
configuration structures and can pass the Leaf Driver Instance Handle to
the leaf driver as a parameter in calls made via the Entry-Point Vector.</p>
<p>Either board logic or an application program may open() the cluster
driver. The cluster driver open() calls the open() function of the leaf
drivers.  The cluster driver open() or read() function can launch the
shared worker task that collects the data.</p>
<p>The cluster driver close() function calls the close functions of the leaf
drivers.</p>
</section>
<section id="adt7320">
<h2>ADT7320<a class="headerlink" href="#adt7320" title="Permalink to this heading"></a></h2>
<p>Contributed by Augusto Fraga Giachero</p>
<p>The ADT7320 is a SPI temperature sensor with a temperature range of
−40°C to +150°C.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="rwbuffer.html" class="btn btn-neutral float-left" title="rwbuffer.c" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="segger.html" class="btn btn-neutral float-right" title="Segger RTT drivers" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, The Apache Software Foundation.</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>